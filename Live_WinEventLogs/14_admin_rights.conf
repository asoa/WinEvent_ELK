filter {
	if [source_type] =~ /^admin/ {  # TODO: verify this will match on log file named "admin_rights"
	
		# Drop header lines that begin with "TYPE" and "Message" 
		if [message] =~ "^TYPE" { 
			drop {}
		}
		if [message] =~ "^Message" {
			drop {}
		}
		
		csv {
			separator => ","
			columns => ["Message","SubjectUserSid","SubjectUserName","SubjectDomainName","SubjectLogonId","LogonGuid","TargetUserName","TargetDomainName","TargetLogonGuid","TargetServerName","TargetInfo","ProcessId","ProcessName","IpAddress","IpPort","Id","Version","Qualifiers","Level","Task","Opcode","Keywords","RecordId","ProviderName","ProviderId","LogName","ThreadId","MachineName","UserId","TimeCreated","ActivityId","RelatedActivityId","ContainerLog","MatchedQueryIds","Bookmark","LevelDisplayName","OpcodeDisplayName","TaskDisplayName","KeywordsDisplayNames","Properties","PSComputerName","RunspaceId","PSShowComputerName"]
			
			# TODO: some columns contain empty fields; use remove_field setting to remove them; [array] datatype w/ string items
			# remove_field => []
		}
		
		#mutate {
		#	add_tag => ["admin_%TaskDisplayName", "security"]  # TaskDisplayName field contains "Logon"; add security tag to indicate security log
		#}
		
		# Convert TimeCreated field into Kibana compliant format
		date {
			match => ["TimeCreated", "MM/dd/YYYY HH:mm:ss"]  # TimeCreated field is in format "11/28/2016 23:16" TODO: verify this is the right way to parse date 
		}
	}
}